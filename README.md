# squarewave

This repository contains information about generating squarewave signals using arduino hardware via bit-banging using interrupts.

The original motivation was to simulate a signal generated by a rotational-speed sensor. (drehzahlmesser)

The following diagram shows the signal sequence generated by one rotation:

 +---+   +---+   +---+   +--     -+   +---+   +---+                  
 |   |   |   |   |   |   |   ...  |   |   |   |   |
 +   +---+   +---+   +---+        +---+   +---+   +---+---+---+---+---

 1       2       3       4            59      60      61      62

 
As you can see the signal value high is triggered 60 times followed by a short pause.

The initial requirement was that the signal frequency should be as high as to simulate 7000 rotations measured by the rotational-speed sensor.
We denote this frequency as wheel frequency. Since one rotation generates a signal containing 62 sections the signal frequency is 62 times higher.

The microcontroller ATmega328P contained on the Arduino Nano V3 contains three hardware timers capable to generate PWM signals.
But since the signal we want to generate contains a pause at the end of each rotation of the wheel we have to modify the signal PWM singnal in some way.
We are using an interrupt to change the signal values 0/1 which is triggered by a hardware timer at the approriate frequency.
 
Since timer 1 is a 16-bit timer which is counting at 16 Mhz (with prescaler set to 1) it takes 4096 us (4096 microseconds = (1/16 MHz)*2**16) to trigger an overflow.
You can define a compare register to trigger an interrupt if the counter has reached a specific value, i.e. you can trigger at any interval between 1/16 MHz and 4096 us.

The calculation and setting of the output pin which is done in an interrupt service routine needs some amount of cpu cylcles.

The calculation of the signal can be done using the following pseudo code using a global volatile byte typed variable count:

 +---+   +---+   +---+   +--     -+   +---+   +---+                  
 |   |   |   |   |   |   |   ...  |   |   |   |   |
 +   +---+   +---+   +---+        +---+   +---+   +---+---+---+---+---

 0   1   2   3   4   5   6            116 117 118 119 120 121 122 123 
 
- volatile byte count = 0

* set counter of timer 1 to 0
* if (counter % 2 = 0 and counter < 120):
*    set output to 1
* else
*    set output to 0
* count++
* count = count % 124

Now the question remains what is the maximum wheel frequency we can achieve, i.e. how much time or cpu cycles dues interrupt service routine use.

If you have a two signal osciloscpe with an appropriate bandwidth, you can measure this by setting a different output pin to 1 at the beginning and 0 at the end of the routine.



Todo: measure time, attach picture, measure interupt time, calculate maximum frequency with double interrupt time.

Possible Optimizations:
- FastWrite

Setup:
-

Structure:
v1_measurement - contains arduino code and osciloscope output
v1_maximum
   


The used arduino clone "Nano V3.0 CH340" is available at [2].

[1] https://www.heise.de/developer/artikel/Timer-Counter-und-Interrupts-3273309.html (german)
[2] https://www.az-delivery.de/products/nano-v3-0-pro (german)
